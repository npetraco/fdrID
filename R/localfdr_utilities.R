#-------------------------------------------------------
#Count useful things from the histogram of joint scores
#Largely taken from locfdr code
#-------------------------------------------------------
preprocess.z<-function(zscores,bre) {
  
  #Taken from locfdr:
  lo <- min(zscores)
  up <- max(zscores)
  
  zzz <- pmax(pmin(zscores, up), lo)
  breaks <- seq(lo, up, length = bre)
  zh <- hist(zzz, breaks = breaks, plot = F)
  x <- (breaks[-1] + breaks[ - length(breaks)])/2
  y <- zh$counts
  K <- length(y)
  N <- length(zscores)
  
  zinfo<-list(x,y,K,N)
  names(zinfo)<-c("bin midpoints","counts","num bins", "num scores")
  
  return(zinfo)
  
}

#----------------------------------------------------
#Alg to take f's and turn each into an fdr model.
#Largely taken from locfdr code. Follows basically
#Efron 2006 Size, Power and False Discovery Rates
#
#NOTE: Rows of lam.mat are f's generated by a Bayesian Poisson
#regression (cf. Gelman and Hill 2007) onto the 
#hisogram of counts generated by zscores
#---------------------------------------------------
process.f<-function(zscores,xmids,pct0,lam.mat){

  num.sims<-nrow(lam.mat)
  KK<-ncol(lam.mat)
  
  #From locfdr
  pctup <- 1 - pct0
  pctlo <- pct0
  lo0 <- quantile(zscores, pctlo)
  hi0 <- quantile(zscores, pctup)
  nx <- length(xmids)
  i0 <- (1.:nx)[xmids > lo0 & xmids < hi0]
  x0 <- xmids[i0]
  
  delta0.vec<-rep(NA,num.sims)
  sig0.vec<-rep(NA,num.sims)
  p0.vec<-rep(NA,num.sims)
  #p00.vec<-rep(NA,num.sims)
  fdr.mat<-array(NA,dim(lam.mat))
  for(i in 1:num.sims) {
    #From locfdr:
    f<-lam.mat[i,]
    l <- log(f)  
    y0 <- l[i0]
    #Shift axis so central peak is at z=0. Cf. Efron 2006
    imax <- seq(l)[l == max(l)][1]
    xmax <- xmids[imax]
    X00 <- cbind(x0 - xmax, (x0 - xmax)^2)
    
    #Parabolic fit to central peak of f (i.e. use central matching alg):
    lr <- lm(y0 ~ X00)
    co <- lr$coef
    X0 <- cbind(1, x - xmax, (x - xmax)^2)
    delta0 <-  - co[2.]/(2. * co[3.]) + xmax #Same as Efron 2006
    sig0 <- 1./sqrt(-2. * co[3.])            #Same as Efron 2006
    delta0.vec[i] <- delta0
    sig0.vec[i] <- sig0
    
    #WHY DOESNT THIS WORK TO GET p0??????????????????????????????????????????????????????!!!!!!!!!!!!!!!!!
    #p00 <- exp(co[1.] + 0.5*( (delta0^2/sig0^2) + log( 2*pi*sig0^2) ) )
    #p00.vec[i] <- p00
    
    l0 <- as.vector(X0 %*% co)
    f0p <- exp(l0)
    p0 <- sum(f0p)/sum(f)
    p0.vec[i] <- p0 
    
    fdr.sim = pmin((f0p)/f, 1)
    fdr.mat[i,] <- fdr.sim
    
  }
  
  sim.proc.info<-list(delta0.vec, sig0.vec, p0.vec,fdr.mat)
  names(sim.proc.info) <- c("delta0","sigma0","p0","fdr")
  
  return(sim.proc.info)
  
}